<script setup>
import { ref, watch, onMounted } from 'vue'
import axios from "axios";

// ----------------------------------------------------------------------------------- 变量定义

const talkAllMessage = ref([])      // 所有对话内容的html代码数组
// const history = ref([]) // 历史记录数组

const messageInput = ref('') // 输入框内容
const message = ref('') // 处理后的输入内容
const rowsNum = ref(1)  // 输入框行数

const ai_response_content = ref('') // ai的单条回复内容
let response_box = ref()   // ai最新答复的聊天框
let talkBody = ref()       // 整体聊天框
let foot_input = ref()       // 输入框

let isBottom = ref(true) // 是否位于底部
let controlable = ref(true)   // 用户是否可输入的状态变量
let socket  // 双向通信通道

// 大模型选择
const modelValue = ref('1.0')
const modelOptions = ref([{value: '1.0',label: 'Murphy-1.0'},{value: '2.0',label: 'Murphy-2.0'}])
let testURL = ref('region-3.seetacloud.com:19897')

// 广告图片数组
const imgList = ref(['ad1', 'ad2', 'ad3'])
import ad1 from '/src/assets/ad1.png'
import ad2 from '/src/assets/ad2.png'
import ad3 from '/src/assets/ad3.png'
let intervalId = ref()  // 广告轮播计时器id
const adIndex = ref(0) // 广告页数下标
let imgWidth = ref(0) // 广告图片宽度

// ----------------------------------------------------------------------------------- 函数定义
// ---------------------------------------------------- 广告逻辑
// 广告自动滚动
const adChange = () => {
  const adimg = document.querySelector('.mainbody_ad img')
  imgWidth.value = parseFloat(window.getComputedStyle(adimg).width)
  const pointList = document.querySelector('.pointList')
  const imgList = document.querySelector('.mainbody_ad .img-container')
  for (let i = 0; i < pointList.children.length; i++) {
    imgList.children[i].style.transform = 'translateX(' + -imgWidth.value * adIndex.value + 'px)'
    pointList.children[i].style.backgroundColor = 'gray'
  }
  const point = pointList.children[adIndex.value]
  point.style.backgroundColor = 'white'
}

// 广告手动翻页
const adIndexChange = (value) => {
  adIndex.value += value
  if(adIndex.value === -1){
    adIndex.value = imgList.value.length - 1
  } else if(adIndex.value === imgList.value.length) {
    adIndex.value = 0
  }
  adChange()
}

// 开启定时器
const startTimer = () => {
  adChange()
  // 每三秒进行一次滚动
  intervalId.value = setInterval(()=>{
    adIndex.value++
    if (adIndex.value >= imgList.value.length) {
      adIndex.value = 0
    }
    adChange()
  }, 3000)
}

// 点击广告的下标圆点
const adChoice = (index) => {
  adIndex.value = index
  adChange()
}

// 获取海报图片路径
const getImagePath = (imageName) => {
  if (imageName === 'ad1') return ad1
  if (imageName === 'ad2') return ad2
  if (imageName === 'ad3') return ad3
}
// ---------------------------------------------------- 发送逻辑
// 发送消息
const sendMessage = async () => {
  // 过滤用户携带的<>括号
  message.value = messageInput.value.replace(/</g, '&lt;').replace(/>/g, '&gt;')
  if (messageInput.value.trim() === '' || controlable.value === false) return
  controlable.value = false

  // 将用户输入上传到页面
  let str = '<div class="human">'
          + '  <div class="talk_box right">' + message.value + '</div>'
          + '  <div><div class="head_pic human_pic"></div></div>'
          + '</div>'
  talkAllMessage.value.push(str)

  // 用户发送消息后1ms，滑动到底部，发送请求
  setTimeout(() => {
    scrollToBottom()
    try {
      // 尝试发送消息
      if (socket.readyState === WebSocket.OPEN) {
        socket.send(message.value)
        times.value = 1
      } else {
        ElMessage({
          message: '未连接服务器!',
          type: 'error',
        })
      }
    } catch (error) {
      // 处理连接错误
      ElMessage({
        message: '连接错误!',
        type: 'error',
      })
    }
    // 清空输入框
    messageInput.value = ''
    foot_input.value.value = ''
    foot_input.value.style.height = 25 + 'px'
  }, 1)

  // AI回复样式框架
  str = '<div class="machine">' +
        '  <div><div class="head_pic machine_pic"></div></div>' +
        '  <div class="talk_box">......</div>' +
        '</div>'
  talkAllMessage.value.push(str)

  // AI回复消息，获取最新回答的聊天框
  setTimeout(() => {
    scrollToBottom()
    const children = talkBody.value.children
    response_box = children[children.length - 1]
  }, 2)
}

// 连接大模型
const connect = () => {
  // 建立双向通信npm
  socket = new WebSocket('ws://' + testURL.value + '/ws/v1/chat/completions')
  // 连接建立后调用函数
  socket.addEventListener('open', (event) => {
    console.log('连接开启')
    ElMessage({
      message: '连接成功!',
      type: 'success',
    })
    localStorage.setItem('testURL', JSON.stringify(testURL.value))
  })

  let flag = false // 去掉</pre>后的一个换行符
  let isCode = false
  // 处理服务器返回数据
  socket.addEventListener('message', (event) => {
    let temp = event.data.replace(/</g, '&lt;')
    makeQueue(temp) // 制作句子队列，等待转语音
    // 设置聊天框内的文字内容
    const target = response_box.querySelector('.talk_box')
    if(target.innerHTML === '......') target.innerHTML = ''
    // 传输已结束
    if(temp === '[DONE]'){
      console.log('---传输完毕，请继续输入---')
      // times.value = 3
      sentence.value = ''
      ai_response_content.value = ''
      controlable.value = true
    }
    // 传输文字内容
    else if( isCode === false ) {
        if (event.data === '\n') {
            ai_response_content.value = '<br>'
            if( flag === true ) { // 去掉</pre>后的一个换行符
              ai_response_content.value = ''
              flag = false
            }
        } else if(event.data ===' '){
            ai_response_content.value = '&nbsp;'
        } else if (event.data === '```') {
            isCode = true
            ai_response_content.value = '<pre style="display: inline-block;padding: 10px;background-color: black;color: white">########################################################&nbsp;&nbsp;</pre>'
        } else {
            ai_response_content.value = temp
        }
        target.innerHTML += ai_response_content.value
    }
    // 传输代码内容
    else if ( isCode === true ) {
        if (event.data === '```') {
            isCode = false
            flag = true
            target.innerHTML = target.innerHTML.slice(0, -6) + '########################################################</pre>'
        } else {
            ai_response_content.value = target.innerHTML.slice(0, -6);
            ai_response_content.value += temp + '</pre>' // </code>
            // 将新文本设置回元素
            target.innerHTML = ai_response_content.value;
        }
    }
    scrollToBottom()
  });

  // 连接关闭后调用函数
  socket.addEventListener('close', () => {
    const target = response_box.querySelector('.talk_box')
    // target.textContent = ai_response_content.value
    target.innerHTML = ai_response_content.value
    console.log('连接已关闭，请退出');
    ElMessage.error('连接已关闭，请退出')
    ai_response_content.value = ''
    controlable.value = true
  });
}
// 队列封装
function createQueue() {
  const items = [];

  // 入队操作
  function inqueue(element) {
    items.push(element);
  }

  // 出队操作
  function outqueue() {
    if (isEmpty()) {
      return null;
    }
    return items.shift();
  }

  // 查看队头元素
  function front() {
    if (isEmpty()) {
      return null;
    }
    return items[0];
  }

  // 检查队列是否为空
  function isEmpty() {
    return items.length === 0;
  }

  // 获取队列长度
  function size() {
    return items.length;
  }

  // 清空队列
  function clear() {
    items.length = 0;
  }

  // 返回队列对象
  return {
    inqueue,
    outqueue,
    front,
    isEmpty,
    size,
    clear
  };
}

const times = ref(1)
const msgQueue = createQueue()
const voiceQueue = createQueue()
const sentence = ref('') // 获取一句句子
// 制作句子队列，等待转语音
const makeQueue = async(temp) => {
  if (onlyMark(temp.trim())) {  // 若遇到标点符号，分割，赋值句子
    if (sentence.value !== '') {  // 不为空才将句子压入队列，等待进行语音转换
      msgQueue.inqueue(sentence.value)
      sentence.value = ''
      // 只在前若干次次执行的时候在这里进行请求，请求前几句
      if(times.value > 0) {
        let temp = msgQueue.front()
        msgQueue.outqueue()
        await sendMessageToMicrosoft(temp, 0)
        // 只在第一次时在这里播放，此后都是在音频播放判断结束后进行播放
        times.value--
        if(times.value === 0){
          playAudio()
        }
      }
    }
  } else {
    sentence.value += temp
  }
}

// 播放语音
const playAudio = () => {
  let audio = voiceQueue.front()
  audio.play()
  let flag = 0

  // 添加timeupdate事件监听器
  audio.addEventListener('timeupdate', () => {
    const currentTime = audio.currentTime
    const duration = audio.duration
    // 如果当前时间距离结束不足三秒
    if (duration - currentTime < 3) {
      if (flag === 0) {
        flag = 1
        if(msgQueue.size()>0){
          sendMessageToMicrosoft(msgQueue.front(), 1)
        }
      }
    }
  })

  // 在音频播放结束时执行函数
  audio.addEventListener('ended', () => {
      voiceQueue.outqueue()
      if (!voiceQueue.isEmpty()) {
        // voiceQueue不为空，继续播放
        playAudio()
      } else {
        console.log('语音播放完毕')
        ElMessage.success('播放完毕')
        // ElMessage.error('播放完毕')
      }
  });
}

// 向微软发送请求语音合成api请求，将
const sendMessageToMicrosoft = async(msg, num) => {
    if (num===1) msgQueue.outqueue()
    const subscriptionKey = '854b68902a2d42f39acb0b8fb789342d';
    const region = 'japaneast';
    const aiName = 'zh-CN-XiaoxiaoNeural'
    const str = '<speak version="1.0" xml:lang="en-us"><voice xml:lang="en-US" name="' + aiName + '">' + msg + '</voice></speak>'
    const tokenResponse = await fetch(`https://${region}.api.cognitive.microsoft.com/sts/v1.0/issuetoken`, {
      method: 'POST',
      headers: {
        'Ocp-Apim-Subscription-Key': subscriptionKey
      }
    });
    if (tokenResponse.ok) {
      const accessToken = await tokenResponse.text()
      const synthesisResponse = await fetch(`https://${region}.tts.speech.microsoft.com/cognitiveservices/v1`, {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer ' + accessToken,
          'Content-Type': 'application/ssml+xml',
          'X-Microsoft-OutputFormat': 'riff-24khz-16bit-mono-pcm',
          'User-Agent': 'YOUR_RESOURCE_NAME'
        },
        body: str,
      });
      if (synthesisResponse.ok) {
        const audioBlob = await synthesisResponse.blob()
        const audioUrl = URL.createObjectURL(audioBlob)
        const audio = new Audio();
        audio.src = audioUrl;
        audio.type = 'audio/wav';
        // 将请求得到的语音放入队列
        // 将获取到的语音压入队列
        voiceQueue.inqueue(audio)
        console.log('---请求音频完成, 请求内容：---\n' +  msg)
        // msgQueue.outqueue()
      } else {
        console.error('api访问错误:', synthesisResponse.body);
      }
    } else {
      console.log('token访问失败!访问次数过于频繁，请稍后重试')
    }
}
// 包含以下标点符号的字符串
const onlyMark = (temp) => {
  const mark = ["。", "！", "？", "!", ".", "?", "：", "**"]
  return mark.includes(temp)
}

// 中止回答
const stopConnection = async () => {
  await axios.post('http://' + testURL.value + '/stop-processing')
  ai_response_content.value = ''
  controlable.value = true
}
// 点击滚动到底部按钮
const clickToBottom = () => {
  talkBody.value.scrollTo({
    top: talkBody.value.scrollHeight,
    // behavior: 'smooth',
  });
}
// 平滑滚动到底部
const scrollToBottom = () => {
  if(isBottom.value){
    talkBody.value.scrollTo({
      top: talkBody.value.scrollHeight,
      // behavior: 'smooth',
    });
  }
}

// ---------------------------------------------------- 输入框逻辑
// 监听输入内容变化
watch(messageInput, () => {
  adjustHeight()
})

// 控制输入框高度
const adjustHeight = () => {
  switch ( foot_input.value.scrollHeight ) {
    case 35: rowsNum.value = 1;break;
    case 60: rowsNum.value = 2;break;
    case 85: rowsNum.value = 3;break;
    case 110: rowsNum.value = 4;break;
    case 135: rowsNum.value = 5;break;
    default: rowsNum.value = 6;break;
  }
  const toBottomButton = document.querySelector('.to_bottom_button')
  if (toBottomButton) {
    toBottomButton.style.bottom = 80 + (rowsNum.value - 1) * 25 + 'px'
  }
  foot_input.value.style.height = rowsNum.value * 25 + 'px'
  scrollToBottom()
}

// 键盘监听事件
document.addEventListener('keydown', function(event) {
  // 判断按下的键是否是删除键，del键，回车发送键，撤回键
  if (event.key === 'Backspace' || event.key === 'Delete' || (!event.shiftKey && event.key === 'Enter') || (event.ctrlKey && event.key === 'z') ) {
    foot_input.value.style.height = 25 + 'px'
    setTimeout(()=>{
      adjustHeight()
    }, 50)
  }
  // 检测非shift+enter换行：回车发送
  if (!event.shiftKey && event.key === 'Enter') {
    event.preventDefault();
    sendMessage()
  }
})

// ---------------------------------------------------- 其他逻辑
// 清除历史
const clearHistory = () => {
  ElMessageBox.confirm('是否清空会话历史?当前窗口的数据记录将会丢失!', '警告', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  })
      .then(() => {
        // history.value.splice(1, history.value.length - 1)
        // localStorage.setItem('talkHistory', JSON.stringify(history.value))
        ElMessage.success('已清空')
      })
      .catch(() => {

      })
}

// 鼠标滚轮滑动事件
const mousewheel = (event) => {
  // 向上滚动，取消自动滑动
  if (event.deltaY < 0) {
    isBottom.value = false
  }
  if(talkBody.value.scrollHeight - talkBody.value.scrollTop <= talkBody.value.clientHeight + 2) {
    isBottom.value = true
  }
  adChange()
}
// const voiceStartButton = ref()
// // const voiceStartButton = document.getElementById('buttonVoice')
// const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)()
// const voice = () => {
//   console.log(recognition.state)
//   // 检查浏览器是否支持Web Speech API
//   if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
//     // 创建语音识别对象
//     // console.log(recognition)
//     // 设置语言
//     recognition.lang = 'zh-CN'; // 可根据需要设置其他语言
//
//     recognition.onstart = () => {
//       console.log('语音识别已启动');
//     };
//
//     recognition.onend = () => {
//       console.log('语音识别已结束');
//     };
//     // 当识别到语音时触发此事件
//     recognition.onresult = (event) => {
//       console.log('识别中...')
//       const transcript = event.results[0][0].transcript
//       console.log('识别结果：', transcript)
//       // 在这里可以将transcript传递给其他功能或显示在页面上
//     };
//
//     // 启动语音识别
//     voiceStartButton.value.addEventListener('mousedown', () => {
//       console.log('按下了按键')
//       recognition.start();
//     });
//
//     voiceStartButton.value.addEventListener('mouseup', () => {
//       console.log('松开按键')
//       recognition.stop();
//     });
//   } else {
//     console.error('浏览器不支持Web Speech API');
//   }
//
// }
onMounted( () => {
  let str = '<div class="machine">' +
            '  <div>' +
            '    <div class="head_pic machine_pic"></div>' +
            '  </div>' +
            '  <div class="talk_box">测试用文本：<br>测试的基本步骤<br>介绍一下你自己<br>介绍一下深圳<br>用js写一段代码，循环打印1到100之间被3整除的数字</div>' +
            '</div>'
  talkAllMessage.value.push(str)
  talkBody.value = document.querySelector('.talk_body')
  foot_input.value = document.querySelector('.foot_input')
  foot_input.value.style.height = '25px'
  // if (localStorage.getItem('talkHistory')) {
  //   history.value = JSON.parse(localStorage.getItem('talkHistory'))
  // } else {
  //   history.value.push({"role": "system","content": "你是一个智能聊天对话助手，你需要尽可能的回答用户的问题，并与对方亲切的交流。"})
  //   localStorage.setItem('talkHistory', JSON.stringify(history.value))
  // }

  setTimeout(()=>{
    const ad = document.querySelector('.mainbody_ad')
    ad.style.transform = "translateY(0)";
    ad.style.opacity = "1";
  }, 10)

  const imgList = document.querySelector('.mainbody_ad .img-container');
  const arrowContainer = document.querySelector('.mainbody_ad .arrow-container');
  const arrowleft = document.querySelector('.arrow-container .arrowleft');
  const arrowright = document.querySelector('.arrow-container .arrowright');
  imgList.addEventListener('mouseenter', function() {
    clearInterval(intervalId.value);
    arrowleft.style.display = 'block'
    arrowright.style.display = 'block'
  })
  imgList.addEventListener('mouseleave', function() {
    startTimer()
    arrowleft.style.display = 'none'
    arrowright.style.display = 'none'
  })
  arrowContainer.addEventListener('mouseover', function() {
    clearInterval(intervalId.value);
    arrowleft.style.display = 'block'
    arrowright.style.display = 'block'
  })
  arrowContainer.addEventListener('mouseout', function() {
    arrowleft.style.display = 'none'
    arrowright.style.display = 'none'
  })
  document.addEventListener('wheel', mousewheel)
  // voiceStartButton.value = document.querySelector('.button_voice')
  startTimer()
  connect()
  // if(localStorage.getItem('testURL')){
  //   testURL.value = JSON.parse(localStorage.getItem('testURL'))
  // }
  // const myQueue = createQueue();
})
</script>

<template>
  <div class="mainbody">
    <div class="mainbody_talk">
      <div class="talk_head">
        <el-select v-model="modelValue" placeholder="请选择">
          <el-option
              v-for="item in modelOptions"
              :key="item.value"
              :label="item.label"
              :value="item.value">
          </el-option>
        </el-select>
        <div>智能Murphy</div>
<!--        <button @click="clearHistory()">清空会话历史</button>-->
        <input style="width: 350px;height: 90%" v-model="testURL" placeholder="输入测试链接...">
        <button style="width: auto" @click="connect()">←点击连接该端口</button>
<!--        <button style="width: auto" id="buttonVoice">语音播报</button>-->
      </div>
      <div class="talk_body" @scroll="mousewheel">
        <div v-if="!isBottom" class="to_bottom_button" @click="clickToBottom">↓</div>
        <div v-for="item in talkAllMessage" :key="item" v-html="item"/>
      </div>
      <div class="talk_foot">
        <textarea v-model="messageInput" placeholder="请输入内容" class="foot_input" />
        <button class="button_send" @click="sendMessage()" v-if="controlable">发送</button>
<!--        <el-button style="border: 1px solid black;" @click="sendMessage()" disabled loading v-else/>-->
        <button class="button_stop" @click="stopConnection()" v-else>停止</button>
      </div>
    </div>
    <div class="mainbody_ad">
      <div class="img-container" style="display: flex">
        <img v-for="item in imgList" :key="item" :src="getImagePath(item)">
      </div>
      <div class="arrow-container">
        <div class="arrowleft" @click="adIndexChange(-1)">&lt;</div>
        <div class="arrowright" @click="adIndexChange(1)">></div>
      </div>
      <div class="pointList">
        <div class="point" v-for="(item, index) in imgList.length" :key="item"  @click="adChoice(index)"></div>
      </div>
    </div>
  </div>
</template>

<style>
  /* 主体部分 */
  .mainbody{
    width: 100vw;
    /*min-width: 1000px;*/
    /*min-height: 800px;*/
    box-sizing: border-box;
    display: flex;
    padding: 10px;
    /*高度充满父容器*/
    position: absolute;
    top: 50px;
    bottom: 0;
  }
  .mainbody_talk{
    width: 60vw;
    min-width: 700px;
    height: 96%;
    border: 7px solid rgba(15, 178, 145, 0.5);
    border-radius: 3px;
    margin: auto 50px;
    box-sizing: border-box;
    position: relative;
    display: flex;
    flex-direction: column;
    box-shadow: 15px 15px 10px 0 rgba(0, 0, 0, 0.3);
  }
  .talk_head{
    height: 50px;
    line-height: 50px;
    display: flex;
    background-color: rgb(240, 251, 255);
    position: relative;
  }
  .talk_head .el-select{
    width: 150px;
    position: absolute;
    margin: 9px auto auto 15px;
    border-radius: 5px;
  }
  .talk_head div {
    margin: auto;
  }
  .talk_head button {
    width: 100px;
    height: 80%;
    margin: 5px 15px auto auto;
    position: absolute;
    right: 0;
    border: 1px solid gray;
    color: black;
    border-radius: 5px;
    cursor: pointer;
    background-color: #fff;
  }
  .talk_body{
    width: 100%;
    box-sizing: border-box;
    background-color: #fff;
    border-top: rgba(15, 178, 145, 0.7) 3px solid;
    border-bottom: rgba(15, 178, 145, 0.7) 3px solid;
    flex: 1;
    padding: 10px;
    margin-bottom: 0;
    overflow: auto;
  }
  .talk_body::-webkit-scrollbar {
    width: 15px;
  }
  .talk_body::-webkit-scrollbar-thumb {
    background-color: #bbb; /* 设置滚动条的颜色为浅灰色 */
  }
  .talk_body::-webkit-scrollbar-track {
    background-color: #fff; /* 设置滚动条背景颜色为纯白色 */
  }
  .to_bottom_button {
    width: 40px;
    height: 40px;
    position: absolute;
    right: 40px;
    bottom: 80px;
    border-radius: 20px;
    border: 1px solid black;
    box-sizing: border-box;
    background-color: #fff;
    text-align: center;
    line-height: 40px;
    cursor: pointer;
  }
  .to_bottom_button:hover {
    background-color: #ddd;
  }
  .head_pic{
    width: 60px;
    height: 60px;
    border-radius: 30px;
    border: solid 1px gray;
    margin: 5px;
    background-position: center;
    background-size: cover;
    background-repeat: no-repeat;
  }
  .machine_pic{
    background-image: url('../assets/logo.png');
    background-position: center bottom 5px;
  }
  .human_pic{
    background-image: url('../assets/user.jpg');
  }
   /*对话框内容*/
  .talk_box{
    min-width: 20px;
    height: auto;
    border-radius: 5px;
    border: 1px solid black;
    /*margin: 20px 10px 20px 10px;*/
    margin: 10px;
    padding: 15px 10px 15px 10px;
    /*box-shadow: 5px 5px 13px 0 rgba(0, 0, 0, 0.3);*/
    overflow-x: auto;
    scrollbar-width: thin;
    scrollbar-color: #ccc #fff; /* 设置滚动条颜色和背景颜色 */
    font-size: 15px;
    line-height: 22px;
  }
  .talk_box::-webkit-scrollbar {
    height: 10px; /* 设置横向滚动条的高度 */
  }

  .talk_box::-webkit-scrollbar-thumb {
    background-color: #ccc; /* 设置滚动条的颜色为浅灰色 */
    border-radius: 5px;
  }

  .talk_box::-webkit-scrollbar-track {
    background-color: #fff; /* 设置滚动条背景颜色为纯白色 */
    border-radius: 5px;
  }
  .machine{
    display: flex;
    margin: 10px 80px auto auto;
  }
  .human{
    display: flex;
    margin: 10px auto auto 40px;
  }
  .right{
    margin-left: auto;
  }
  .talk_foot{
    width: 100%;
    display: flex;
    margin-top: 0;
    background-color: rgb(240, 251, 255);
  }
  .talk_foot button{
    width: 4vw;
    min-width: 70px;
    height: 38px;
    margin: auto auto 10px auto;
    color: black;
    border: 1px solid black;
    border-radius: 5px;
    cursor: pointer;
  }
  .button_send{
    background-color: #fff;
  }
  .button_stop {
    background-color: rgba(255, 0, 0, 0.5);
  }
  .button_stop:hover {
    background-color: rgba(255, 20, 0, 0.9);
    border: 1px solid #3498db;
  }
  .button_send:hover, .talk_head button:hover{
    color: #3498db;
    border: 1px solid #3498db;
    background-color: rgb(236, 245, 255);
  }
  .foot_input{
    padding: 5px 10px 5px 10px;
    width: 48vw;
    min-width: 570px;
    resize: none;
    margin: 10px 0 10px 10px;
    border-radius: 5px;
    font-size: 20px;
    transition: border 0.3s;
    border: 2px solid #dddddd;
    line-height: 25px;
  }
  .foot_input:focus {
    outline: none;
    border: 2px solid #3498db;
  }
  /*广告*/
  .mainbody_ad{
    /*width: 400px;*/
    /*min-width: 400px;*/
    /*height: 800px;*/
    width: 20%; /* 设置宽度为视口宽度的20% */
    height: auto; /* 高度自适应，保持原始宽高比 */
    max-width: 400px; /* 设置最大宽度，以防止图像放大过多 */
    max-height: 800px; /* 设置最大高度 */
    min-width: 200px;
    min-height: 400px;
    border: 1px solid black;
    margin: 50px auto auto 10%;
    box-sizing: border-box;
    border-radius: 5px;
    overflow: hidden;
    box-shadow: 15px 15px 10px 0 rgba(0, 0, 0, 0.3);
    cursor: pointer;
    position: relative;

    transition: all 1s;
    opacity: 0.5;
    transform: translateY(50px); /* 初始时从左往右偏移 */
  }
  .mainbody_ad img{
    max-width: 100%;
    height: auto;
    object-fit: contain;
    transition: all 0.5s;
  }
  .arrow-container{
    position: absolute;
    width: 100%;
    height: 40px;
    bottom: 50%;
    display: flex;
  }
  .arrowleft{
    width: 30px;
    height: 40px;
    background-color: rgba(0, 0, 0, 0.3);
    border-bottom-right-radius: 20px;
    border-top-right-radius: 20px;
    color: white;
    font-size: 30px;
    line-height: 37px;
    display: none;
  }
  .arrowright{
    width: 30px;
    height: 40px;
    margin-left: auto;
    background-color: rgba(0, 0, 0, 0.5);
    border-bottom-left-radius: 20px;
    border-top-left-radius: 20px;
    color: white;
    font-size: 30px;
    line-height: 37px;
    text-indent: 6px;
    display: none;
  }
  .pointList{
    position: absolute;
    height: 30px;
    background-color: rgba(0, 0, 0, 0.6);
    border-radius: 20px;
    line-height: 30px;
    bottom: 3%;
    display: flex;
    margin: auto;
    left: 50%;
    transform: translateX(-50%);
  }
  .point{
    width: 10px;
    height: 10px;
    border-radius: 10px;
    background-color: white;
    border: 2px solid black;
    margin: 9px 10px 10px 10px;
  }
</style>